"use strict";var jsxRuntime=require("react/jsx-runtime"),e=require("react"),style=require("../style.cjs.js");const FixedSizeBody=e.forwardRef(({childHeight,renderAhead=20,rowList,renderRow,renderEmptyMessage,tableRef,tableHeight,headerHeight,...props},ref)=>{const[scrollTop,setScrollTop]=e.useState(0),[height,setHeight]=e.useState(tableHeight-headerHeight);e.useEffect(()=>{setHeight(tableHeight-headerHeight)},[tableHeight,headerHeight]),e.useEffect(()=>{function handleScroll(e){requestAnimationFrame(()=>{setScrollTop(e.target.scrollTop)})}const scrollContainer=tableRef.current;return setScrollTop(scrollContainer?.scrollTop||0),scrollContainer?.addEventListener("scroll",handleScroll),()=>scrollContainer?.removeEventListener("scroll",handleScroll)},[tableRef]);const rowNodes=e.useMemo(()=>rowList.map((row,index)=>renderRow(row,index)).filter(Boolean),[rowList,renderRow]),itemCount=rowNodes.length;let startNode=Math.floor(scrollTop/childHeight);startNode=Math.max(0,startNode-renderAhead);let visibleNodeCount=Math.ceil(height/childHeight)+2*renderAhead;visibleNodeCount=Math.min(itemCount-startNode,visibleNodeCount);const topPadding=startNode*childHeight+"px",bottomPadding=(itemCount-startNode-visibleNodeCount)*childHeight+"px",visibleChildren=e.useMemo(()=>[...rowNodes].slice(startNode,startNode+visibleNodeCount),[rowNodes,startNode,visibleNodeCount]);return jsxRuntime.jsx(style.Body,{style:{height},ref,...props,children:renderEmptyMessage?renderEmptyMessage():jsxRuntime.jsxs(jsxRuntime.Fragment,{children:[jsxRuntime.jsx(style.Spacer,{style:{minHeight:topPadding}}),visibleChildren,jsxRuntime.jsx(style.Spacer,{style:{minHeight:bottomPadding}})]})})});exports.FixedSizeBody=FixedSizeBody;
//# sourceMappingURL=FixedSizeBody.cjs.js.map
