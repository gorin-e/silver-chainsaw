/// <reference types="react" />
type Direction = 'horizontal' | 'vertical';
type Options = {
    mirrorRef: React.RefObject<HTMLElement>;
    dimension: 'xl' | 'l' | 'm' | 's';
    /** Функция для отрисовки контента перетаскиваемой плашки */
    renderMirror: (dragItem: HTMLElement | null) => void;
    /** Функция для очистки контента перетаскиваемой плашки */
    removeMirror: () => void;
    /** Функция для обновления сведений о перетаскиваемом элементе. Н-р, при drag&drop строк, распределенных по группам,
     * строка может в ходе одного перетаскивания изменяться (удаляться, добавляться), поэтому элемент строки нужно обновлять.
     * id - уникальный идентификатор, по которому можно извлечь перетаскиваемый элемент,
     * seacrhInGroup - признак того, нужно ли проводить дополнительный поиск внутри группы (актуально при drag&drop строк,
     * если строка перемещена в свернутую группу, то сама строка не рендерится на экране, и все вычисления нужно производить относительно заголовка группы) */
    updateDragItem?: (id: any, seacrhInGroup?: boolean) => HTMLElement | null;
    /** Проверяет возможность перемещения el в target-контейнер из source-контейнера, где el будет встроен перед элементом sibling */
    accepts?: (el: HTMLElement | null, target: HTMLElement | null, source: HTMLElement | null, sibling: HTMLElement | null) => boolean;
    /** Проверяет, можно ли начать процесс перетаскивания el, где handle - это элемент, на котором произошло событие mousedown,
     * el - это любой элемент между handle и родительским контейнером (взят из o.containers),
     * утилита проходит циклом по всем элементам между handle и родительским контейнером и для кажого el вызывает функцию invalid
     */
    invalid?: (el: HTMLElement, handle: HTMLElement) => boolean;
    direction?: Direction;
};
export declare function dragObserver(initialContainers: HTMLElement[], options: Options, onDrop?: (item: HTMLElement | null, reference: HTMLElement | null, immediate?: HTMLElement) => void, onDragStart?: () => void, onDragEnd?: (item: HTMLElement | null) => void): {
    containers: HTMLElement[];
    unobserve: () => void;
    dragging: boolean;
};
export {};
//# sourceMappingURL=dragObserver.d.ts.map