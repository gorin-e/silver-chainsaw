import type { PropsWithChildren, ReactPortal } from 'react';
export declare const PositionedPortalContainer: import("styled-components/dist/types").IStyledComponentBase<"web", import("styled-components").FastOmit<import("react").DetailedHTMLProps<import("react").HTMLAttributes<HTMLDivElement>, HTMLDivElement>, never>> & string;
export interface PositionInPortalProps extends React.ComponentProps<'div'> {
    /** Элемент, относительно которого позиционируется портал */
    targetElement: Element | null;
    /** Контейнер, внутри которого будет отрисован портал, по умолчанию портал рендерится в document.body */
    rootRef?: React.RefObject<HTMLElement>;
    /** Отрисовка портала на всю ширину контейнера */
    fullContainerWidth?: boolean;
}
/**
 * При фиксированном позиционировании (как у PositionedPortalContainer) элемент позиционируется
 * всегда относительно исходного содержащего блока (окна браузера).
 * Исключение, когда один из его предков имеет свойство transform, perspective, или filter,
 * установленное на что-то иное, кроме none, в этом случае этот предок ведет
 * себя как содержащий блок. Тогда top, right, bottom и left элемента рассчитываются относительно этого содержащего блока.
 * Если у такого предка кроме transform задано свойство overflow: hidden, то элемент будет обрезаться по его краям.
 *
 * В связи с вышеописанным в качестве контейнера для портала рекомендуется выбирать элемент, у предков которого нет свойств
 * transform, perspective, или filter отличных от none. Также рекомендуется размещать контейнер портала в самом низу dom-дерева,
 * чтобы избежать возможных конфликтов стилей.
 */
export declare const PositionInPortal: ({ targetElement, rootRef, fullContainerWidth, ...props }: PropsWithChildren<PositionInPortalProps>) => ReactPortal;
//# sourceMappingURL=PositionInPortal.d.ts.map