"use strict";var jsxRuntime=require("react/jsx-runtime"),e=require("react"),keyboardKey=require("../common/keyboardKey.cjs.js"),index=require("../Badge/index.cjs.js"),MenuItem=require("../Menu/MenuItem.cjs.js"),style=require("./style.cjs.js"),debounce=require("../common/utils/debounce.cjs.js");const TabMenu=({tabs,dimension="l",underline=!1,mobile=!1,alignSelf="flex-end",activeTab,onChange,dropContainerCssMixin,dropContainerClassName,dropContainerStyle,...props})=>{const[openedMenu,setOpenedMenu]=e.useState(!1),[visibilityMap,setVisibilityMap]=e.useState({});e.useEffect(()=>{const visibility=tabs.reduce((initialMap,_,index)=>(initialMap[index]=!0,initialMap),{});setVisibilityMap(visibility)},[tabs]);const tabsWithRef=e.useMemo(()=>tabs.map(tab=>({...tab,ref:e.createRef()})),[tabs]),overflowMenuRefs=e.useMemo(()=>tabs.slice(0,tabs.length-1).map((_,index)=>({ref:e.createRef(),isVisible:visibilityMap[index]&&!visibilityMap[index+1]})),[tabs,visibilityMap]),currentOverflowMenuRef=e.useMemo(()=>{const visibleMenu=overflowMenuRefs.find(item=>item.isVisible);return visibleMenu?visibleMenu.ref:null},[overflowMenuRefs,visibilityMap]),visibleRefsMap=e.useMemo(()=>{let refsMap=[];return mobile?refsMap=tabsWithRef.map(item=>item.ref):(tabsWithRef.forEach((item,index)=>{visibilityMap[index]&&refsMap.push(item.ref)}),null!==currentOverflowMenuRef&&refsMap.push(currentOverflowMenuRef)),refsMap},[visibilityMap,tabsWithRef,currentOverflowMenuRef,overflowMenuRefs,mobile]),tablistRef=e.useRef(null),underlineRef=e.useRef(null),activeTabIsVisible=e.useMemo(()=>{const activeTabIndex=tabsWithRef.findIndex(item=>item.id===activeTab);return visibilityMap[activeTabIndex]},[tabsWithRef,activeTab,visibilityMap]),modelAllTabs=e.useMemo(()=>tabsWithRef.map(item=>({id:item.id,render:options=>e.createElement(MenuItem.MenuItem,{dimension,...options,key:item.id},jsxRuntime.jsxs(style.MenuItemWrapper,{children:[item.icon&&jsxRuntime.jsx(style.IconWrapper,{$dimension:dimension,children:item.icon}),item.content,void 0!==item.badge&&jsxRuntime.jsx(style.BadgeWrapper,{children:jsxRuntime.jsx(index.Badge,{"data-badge":!0,dimension:"s",appearance:item.id===activeTab?"info":item.disabled?"lightDisable":"lightInactive",children:item.badge})})]})),disabled:item.disabled})),[dimension,tabs,tabsWithRef,activeTab]),containsActiveTab=items=>-1!=items.findIndex(item=>item.id===activeTab),getNextElement=target=>{let currentIndex=visibleRefsMap.findIndex(item=>target===item.current);return currentIndex<visibleRefsMap.length-1?currentIndex++:currentIndex=0,visibleRefsMap[currentIndex].current},getPreviousElement=target=>{let currentIndex=visibleRefsMap.findIndex(item=>target===item.current);return 0===currentIndex?currentIndex=visibleRefsMap.length-1:currentIndex--,visibleRefsMap[currentIndex].current},styleUnderline=(left,width)=>{underlineRef.current&&(underlineRef.current.style.left=left+"px",underlineRef.current.style.width=width+"px",underlineRef.current.style.display=width?"flex":"none")};e.useLayoutEffect(()=>{if(tablistRef.current?.firstElementChild){const resizeObserver=new ResizeObserver(debounce.debounce(function(){const activeTabRef=tabsWithRef.filter(tab=>tab.id===activeTab)?.[0]?.ref.current,left=parseFloat(underlineRef.current?.style.left||"0"),underlineWidth=parseFloat(underlineRef.current?.style.width||"0");if(activeTabRef&&tablistRef.current){const activeTabWidth=activeTabRef.getBoundingClientRect().width,activeTabLeft=activeTabRef.getBoundingClientRect().left-tablistRef.current.getBoundingClientRect().left+tablistRef.current.scrollLeft;activeTabLeft===left&&activeTabWidth===underlineWidth||styleUnderline(activeTabLeft,activeTabWidth)}activeTabRef&&(mobile||activeTabIsVisible)||styleUnderline(0,0)},100));return resizeObserver.observe(tablistRef.current?.firstElementChild),()=>{resizeObserver.disconnect()}}},[tabsWithRef,activeTab,dimension,visibilityMap]),e.useLayoutEffect(()=>{const observer=new IntersectionObserver(entries=>{const updatedEntries={};entries.forEach(entry=>{const targetNumber=entry.target.dataset.number;void 0!==targetNumber&&(updatedEntries[targetNumber]=entry.isIntersecting&&entry.intersectionRatio>.99)}),setVisibilityMap(prev=>({...prev,...updatedEntries}))},{root:tablistRef.current,threshold:[0,1]});return tablistRef.current&&!mobile&&Array.from(tablistRef.current.children).forEach(item=>{observer.observe(item)}),()=>observer.disconnect()},[tabsWithRef,mobile,visibilityMap]);const handleTabClick=event=>{mobile&&event.currentTarget.scrollIntoView({behavior:"smooth",inline:"center",block:"nearest"}),onChange(event.currentTarget.id),event.currentTarget.blur()},handleTabKeyUp=event=>{const code=keyboardKey.keyboardKey.getCode(event);code!==keyboardKey.keyboardKey.Enter&&code!==keyboardKey.keyboardKey[" "]||onChange(event.currentTarget.id)},getTabIndex=id=>tabsWithRef.findIndex(item=>item.id===id),renderOverflowMenu=id=>{const tabNumber=getTabIndex(id),tabsForMenu=modelAllTabs.slice(tabNumber+1),overflowMenuHidden=tabNumber===tabsWithRef.length-1||!(visibilityMap[tabNumber]&&!visibilityMap[tabNumber+1]),tabIndex=overflowMenuHidden||!tabsForMenu?.filter(item=>item.id===activeTab).length?-1:0,overflowRef=overflowMenuRefs[tabNumber]?overflowMenuRefs[tabNumber].ref:null;return jsxRuntime.jsx(style.OverflowMenuContainer,{$dimension:dimension,$isHidden:overflowMenuHidden,children:jsxRuntime.jsx(style.StyledOverflowMenu,{ref:overflowRef,onOpen:()=>setOpenedMenu(!0),onClose:()=>setOpenedMenu(!1),alignSelf,items:overflowMenuHidden?[]:tabsForMenu,selected:containsActiveTab(tabsForMenu)?activeTab:void 0,dimension,$isActive:containsActiveTab(tabsForMenu),disabled:tabsForMenu.every(tab=>tab.disabled),onChange:id=>{onChange(id),styleUnderline(0,0)},tabIndex,dropContainerCssMixin,dropContainerClassName,dropContainerStyle})})},renderTab=item=>{const{disabled,content,id,icon,badge,ref,...props}=item;return jsxRuntime.jsx(style.Tab,{ref,id,role:"tab",type:"button","aria-selected":id===activeTab,$selected:id===activeTab,tabIndex:id===activeTab?0:-1,$dimension:dimension,disabled,onClick:handleTabClick,onKeyUp:handleTabKeyUp,...props,children:jsxRuntime.jsxs(style.TabContentWrapper,{$dimension:dimension,tabIndex:-1,children:[icon&&icon,jsxRuntime.jsx(style.TabContent,{children:content}),void 0!==badge&&jsxRuntime.jsx(index.Badge,{"data-badge":!0,dimension:"s",appearance:id===activeTab?"info":disabled?"lightDisable":"lightInactive",children:badge})]})},id)};return jsxRuntime.jsxs(style.Wrapper,{role:"tablist",ref:tablistRef,$underline:underline,$mobile:mobile,$dimension:dimension,onKeyDown:event=>{const{target}=event;let newFocusTarget;switch(keyboardKey.keyboardKey.getCode(event)){case keyboardKey.keyboardKey.Tab:activeTabIsVisible||(newFocusTarget=currentOverflowMenuRef,event.preventDefault());break;case keyboardKey.keyboardKey.ArrowLeft:newFocusTarget=(target=>{let previousElement=getPreviousElement(target);for(;previousElement?.disabled;)previousElement=getPreviousElement(previousElement);return previousElement})(target),event.preventDefault();break;case keyboardKey.keyboardKey.ArrowRight:newFocusTarget=(target=>{let nextElement=getNextElement(target);for(;nextElement?.disabled;)nextElement=getNextElement(nextElement);return nextElement})(target),event.preventDefault()}!openedMenu&&newFocusTarget&&newFocusTarget.focus()},...props,children:[tabsWithRef.map((item,index)=>{const{id}=item,tabNumber=getTabIndex(id),needsOffset=!mobile&&0!==tabNumber&&visibilityMap[tabNumber-1];return jsxRuntime.jsxs(style.TabWrapper,{"data-number":index,$needsOffset:needsOffset,$dimension:dimension,children:[renderTab(item),mobile||tabNumber===tabsWithRef.length-1?null:renderOverflowMenu(id)]},id)}),jsxRuntime.jsx(style.Underline,{ref:underlineRef,"aria-hidden":!0})]})};TabMenu.displayName="TabMenu",exports.TabMenu=TabMenu;
//# sourceMappingURL=index.cjs.js.map
